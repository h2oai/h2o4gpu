<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Gradient Boosting Regressor — h2o4gpu.gradient_boosting_regressor • h2o4gpu</title>

<!-- jquery -->
<script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script>
<!-- Bootstrap -->
<link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.7/flatly/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

<!-- Font Awesome icons -->
<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">

<!-- clipboard.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.7.1/clipboard.min.js" integrity="sha384-cV+rhyOuRHc9Ub/91rihWcGmMmCXDeksTtCihMupQHSsi8GIIRDG0ThDc3HGQFJ3" crossorigin="anonymous"></script>



<!-- pkgdown -->
<link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script>
<script src="../pkgdown.js"></script>
  <link href="../extra.css" rel="stylesheet">
  <script src="../extra.js"></script>
<meta property="og:title" content="Gradient Boosting Regressor — h2o4gpu.gradient_boosting_regressor" />

<meta property="og:description" content="Gradient Boosting Regressor" />
<meta name="twitter:card" content="summary" />


<!-- mathjax -->
<script src='https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->




  </head>

  <body>
    <div class="container template-reference-topic">
      <header>
      <div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">h2o4gpu</a>
        <span class="label label-default" data-toggle="tooltip" data-placement="bottom" title="Released package">0.2.0.9999</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Tutorials
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="../articles/getting_started.html">Getting started - Machine Learning with GPUs</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">News</a>
</li>
<li>
  <a href="../reference/index.html">API Reference</a>
</li>
      </ul>
      
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/h2oai/h2o4gpu-r">
    <span class="fa fa-github"></span>
     
  </a>
</li>
      </ul>
      
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      
      </header>

<div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Gradient Boosting Regressor</h1>
    <small class="dont-index">Source: <a href='https://github.com/h2oai/h2o4gpu/blob/master/R/auto_generated_wrappers.R'><code>R/auto_generated_wrappers.R</code></a></small>
    <div class="hidden name"><code>h2o4gpu.gradient_boosting_regressor.Rd</code></div>
    </div>

    <div class="ref-description">
    
    <p>Gradient Boosting Regressor</p>
    
    </div>

    <pre class="usage"><span class='fu'>h2o4gpu.gradient_boosting_regressor</span>(<span class='kw'>loss</span> <span class='kw'>=</span> <span class='st'>"ls"</span>, <span class='kw'>learning_rate</span> <span class='kw'>=</span> <span class='fl'>0.1</span>,
  <span class='kw'>n_estimators</span> <span class='kw'>=</span> <span class='fl'>100L</span>, <span class='kw'>subsample</span> <span class='kw'>=</span> <span class='fl'>1</span>, <span class='kw'>criterion</span> <span class='kw'>=</span> <span class='st'>"friedman_mse"</span>,
  <span class='kw'>min_samples_split</span> <span class='kw'>=</span> <span class='fl'>2L</span>, <span class='kw'>min_samples_leaf</span> <span class='kw'>=</span> <span class='fl'>1L</span>,
  <span class='kw'>min_weight_fraction_leaf</span> <span class='kw'>=</span> <span class='fl'>0</span>, <span class='kw'>max_depth</span> <span class='kw'>=</span> <span class='fl'>3L</span>, <span class='kw'>min_impurity_decrease</span> <span class='kw'>=</span> <span class='fl'>0</span>,
  <span class='kw'>min_impurity_split</span> <span class='kw'>=</span> <span class='kw'>NULL</span>, <span class='kw'>init</span> <span class='kw'>=</span> <span class='kw'>NULL</span>, <span class='kw'>random_state</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>max_features</span> <span class='kw'>=</span> <span class='st'>"auto"</span>, <span class='kw'>alpha</span> <span class='kw'>=</span> <span class='fl'>0.9</span>, <span class='kw'>verbose</span> <span class='kw'>=</span> <span class='fl'>0L</span>,
  <span class='kw'>max_leaf_nodes</span> <span class='kw'>=</span> <span class='kw'>NULL</span>, <span class='kw'>warm_start</span> <span class='kw'>=</span> <span class='fl'>FALSE</span>, <span class='kw'>presort</span> <span class='kw'>=</span> <span class='st'>"auto"</span>,
  <span class='kw'>colsample_bytree</span> <span class='kw'>=</span> <span class='fl'>1</span>, <span class='kw'>num_parallel_tree</span> <span class='kw'>=</span> <span class='fl'>1L</span>, <span class='kw'>tree_method</span> <span class='kw'>=</span> <span class='st'>"gpu_hist"</span>,
  <span class='kw'>n_gpus</span> <span class='kw'>=</span> -<span class='fl'>1L</span>, <span class='kw'>predictor</span> <span class='kw'>=</span> <span class='st'>"gpu_predictor"</span>, <span class='kw'>backend</span> <span class='kw'>=</span> <span class='st'>"h2o4gpu"</span>)</pre>
    
    <h2 class="hasAnchor" id="arguments"><a class="anchor" href="#arguments"></a>Arguments</h2>
    <table class="ref-arguments">
    <colgroup><col class="name" /><col class="desc" /></colgroup>
    <tr>
      <th>loss</th>
      <td><p>loss function to be optimized. 'ls' refers to least squares regression. 'lad' (least absolute deviation) is a highly robust loss function solely based on order information of the input variables. 'huber' is a combination of the two. 'quantile' allows quantile regression (use <code>alpha</code> to specify the quantile).</p></td>
    </tr>
    <tr>
      <th>learning_rate</th>
      <td><p>learning rate shrinks the contribution of each tree by <code>learning_rate</code>. There is a trade-off between learning_rate and n_estimators.</p></td>
    </tr>
    <tr>
      <th>n_estimators</th>
      <td><p>The number of boosting stages to perform. Gradient boosting is fairly robust to over-fitting so a large number usually results in better performance.</p></td>
    </tr>
    <tr>
      <th>subsample</th>
      <td><p>The fraction of samples to be used for fitting the individual base learners. If smaller than 1.0 this results in Stochastic Gradient Boosting. <code>subsample</code> interacts with the parameter <code>n_estimators</code>. Choosing <code>subsample &lt; 1.0</code> leads to a reduction of variance and an increase in bias.</p></td>
    </tr>
    <tr>
      <th>criterion</th>
      <td><p>The function to measure the quality of a split. Supported criteria are "friedman_mse" for the mean squared error with improvement score by Friedman, "mse" for mean squared error, and "mae" for the mean absolute error. The default value of "friedman_mse" is generally the best as it can provide a better approximation in some cases.</p></td>
    </tr>
    <tr>
      <th>min_samples_split</th>
      <td><p>The minimum number of samples required to split an internal node:</p></td>
    </tr>
    <tr>
      <th>min_samples_leaf</th>
      <td><p>The minimum number of samples required to be at a leaf node:</p></td>
    </tr>
    <tr>
      <th>min_weight_fraction_leaf</th>
      <td><p>The minimum weighted fraction of the sum total of weights (of all the input samples) required to be at a leaf node. Samples have equal weight when sample_weight is not provided.</p></td>
    </tr>
    <tr>
      <th>max_depth</th>
      <td><p>maximum depth of the individual regression estimators. The maximum depth limits the number of nodes in the tree. Tune this parameter for best performance; the best value depends on the interaction of the input variables.</p></td>
    </tr>
    <tr>
      <th>min_impurity_decrease</th>
      <td><p>A node will be split if this split induces a decrease of the impurity greater than or equal to this value.</p></td>
    </tr>
    <tr>
      <th>min_impurity_split</th>
      <td><p>Threshold for early stopping in tree growth. A node will split if its impurity is above the threshold, otherwise it is a leaf.</p></td>
    </tr>
    <tr>
      <th>init</th>
      <td><p>An estimator object that is used to compute the initial predictions. <code>init</code> has to provide <code>fit</code> and <code>predict</code>. If NULL it uses <code>loss.init_estimator</code>.</p></td>
    </tr>
    <tr>
      <th>random_state</th>
      <td><p>If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If NULL, the random number generator is the RandomState instance used by <code>np.random</code>.</p></td>
    </tr>
    <tr>
      <th>max_features</th>
      <td><p>The number of features to consider when looking for the best split:</p></td>
    </tr>
    <tr>
      <th>alpha</th>
      <td><p>The alpha-quantile of the huber loss function and the quantile loss function. Only if <code>loss='huber'</code> or <code>loss='quantile'</code>.</p></td>
    </tr>
    <tr>
      <th>verbose</th>
      <td><p>Enable verbose output. If 1 then it prints progress and performance once in a while (the more trees the lower the frequency). If greater than 1 then it prints progress and performance for every tree.</p></td>
    </tr>
    <tr>
      <th>max_leaf_nodes</th>
      <td><p>Grow trees with <code>max_leaf_nodes</code> in best-first fashion. Best nodes are defined as relative reduction in impurity. If NULL then unlimited number of leaf nodes.</p></td>
    </tr>
    <tr>
      <th>warm_start</th>
      <td><p>When set to <code>TRUE</code>, reuse the solution of the previous call to fit and add more estimators to the ensemble, otherwise, just erase the previous solution.</p></td>
    </tr>
    <tr>
      <th>presort</th>
      <td><p>Whether to presort the data to speed up the finding of best splits in fitting. Auto mode by default will use presorting on dense data and default to normal sorting on sparse data. Setting presort to true on sparse data will raise an error.</p></td>
    </tr>
    <tr>
      <th>colsample_bytree</th>
      <td><p>Subsample ratio of columns when constructing each tree.</p></td>
    </tr>
    <tr>
      <th>num_parallel_tree</th>
      <td><p>Number of trees to grow per round</p></td>
    </tr>
    <tr>
      <th>tree_method</th>
      <td><p>The tree construction algorithm used in XGBoost Distributed and external memory version only support approximate algorithm. Choices: ‘auto’, ‘exact’, ‘approx’, ‘hist’, ‘gpu_exact’, ‘gpu_hist’ ‘auto’: Use heuristic to choose faster one. - For small to medium dataset, exact greedy will be used. - For very large-dataset, approximate algorithm will be chosen. - Because old behavior is always use exact greedy in single machine, - user will get a message when approximate algorithm is chosen to notify this choice. ‘exact’: Exact greedy algorithm. ‘approx’: Approximate greedy algorithm using sketching and histogram. ‘hist’: Fast histogram optimized approximate greedy algorithm. It uses some performance improvements such as bins caching. ‘gpu_exact’: GPU implementation of exact algorithm. ‘gpu_hist’: GPU implementation of hist algorithm.</p></td>
    </tr>
    <tr>
      <th>n_gpus</th>
      <td><p>Number of gpu's to use in GradientBoostingRegressor solver. Default is -1.</p></td>
    </tr>
    <tr>
      <th>predictor</th>
      <td><p>The type of predictor algorithm to use. Provides the same results but allows the use of GPU or CPU. - 'cpu_predictor': Multicore CPU prediction algorithm. - 'gpu_predictor': Prediction using GPU. Default for 'gpu_exact' and 'gpu_hist' tree method.</p></td>
    </tr>
    <tr>
      <th>backend</th>
      <td><p>Which backend to use. Options are 'auto', 'sklearn', 'h2o4gpu'. Saves as attribute for actual backend used.</p></td>
    </tr>
    </table>
    

  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
    <h2>Contents</h2>
    <ul class="nav nav-pills nav-stacked">
      <li><a href="#arguments">Arguments</a></li>
                </ul>

  </div>
</div>

      <footer>
      <div class="copyright">
  <p>Developed by Yuan Tang, Navdeep Gill, Erin LeDell, H2O.ai.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://pkgdown.r-lib.org/">pkgdown</a>.</p>
</div>

      </footer>
   </div>

  

  </body>
</html>

